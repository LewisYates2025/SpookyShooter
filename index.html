<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dungeon Sphere Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        /* Custom styles for the game area and sphere */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevents scrollbars */
            touch-action: none; /* Disables browser gestures like pull-to-refresh */
        }
        #game-area {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden; /* This acts as our camera viewport */
        }
        #world-container {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #1e293b; /* slate-800 for a darker dungeon feel */
        }
        #sphere {
            position: absolute;
            display: flex; /* Using flex to center the turret */
            align-items: center;
            justify-content: center;
        }
        #turret {
            position: absolute;
            width: 40px; /* Length of the turret */
            height: 8px; /* Thickness of the turret */
            background-color: #f8fafc; /* slate-50 */
            border-radius: 4px;
            left: 50%; /* Start the turret from the center of the sphere */
            transform-origin: 0% 50%; /* Rotate from the base (left-center) */
        }
        .bullet {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            pointer-events: none; /* Bullets should not interfere with mouse events */
        }
        .enemy-bullet {
            position: absolute;
            background-color: #f87171; /* red-400 */
            box-shadow: 0 0 10px #f87171;
            border-radius: 50%;
            pointer-events: none;
        }
        .enemy {
            position: absolute;
            background-color: #b91c1c; /* A deeper, more menacing red-700 */
            border-radius: 50%;
            box-shadow: 0 0 15px #b91c1c;
            display: flex; /* Using flex to center the turret */
            align-items: center;
            justify-content: center;
        }
        .enemy-chaser {
            position: absolute;
            background-color: #f59e0b; /* amber-500 for the chaser */
            border-radius: 50%;
            box-shadow: 0 0 15px #f59e0b;
        }
        .enemy-turret {
            position: absolute;
            width: 30px; /* Slightly smaller than player's turret */
            height: 6px;
            background-color: #fca5a5; /* red-300, a lighter red */
            border-radius: 3px;
            left: 50%;
            transform-origin: 0% 50%;
            /* No transition, color is set directly by JS */
        }
        .wall {
            position: absolute;
            background-color: #334155; /* Darker slate-700 for dungeon walls */
        }
        .ripple {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: ripple-effect 0.17s linear forwards;
        }
        @keyframes ripple-effect {
            from {
                transform: scale(1);
                opacity: 0.7;
            }
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }
        #game-over-modal {
            display: none; /* Hidden by default */
        }
        .path-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(239, 68, 68, 0.4); /* semi-transparent red */
            border-radius: 50%;
            pointer-events: none;
        }
        #wave-counter, #health-bar-container {
            z-index: 10;
        }
        #wave-cleared-message {
            display: none;
            font-size: 3rem;
            font-weight: bold;
            color: #818cf8; /* A more muted indigo-400 */
            text-shadow: 0 0 15px #818cf8;
            animation: fade-in-out 2s ease-in-out forwards;
            z-index: 10;
        }
        @keyframes fade-in-out {
            0% { opacity: 0; transform: scale(0.8); }
            25% { opacity: 1; transform: scale(1.1); }
            75% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(0.8); }
        }
        #health-bar-container {
            width: 150px;
            height: 20px;
            background-color: #1e293b; /* slate-800 */
            border: 2px solid #475569; /* slate-600 */
            border-radius: 5px;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #22c55e; /* green-500 */
            border-radius: 2px;
            transition: width 0.2s ease-in-out;
        }
        .dodge-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            animation: dodge-trail 0.3s linear forwards;
        }
        @keyframes dodge-trail {
            from { transform: scale(1); opacity: 0.5; }
            to { transform: scale(0); opacity: 0; }
        }
        #joystick-base, #joystick-handle {
            pointer-events: none;
            z-index: 20;
        }
        .fog {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(51, 65, 85, 0.1) 0%, rgba(51, 65, 85, 0) 70%); /* Darker fog */
            animation: pulse 20s infinite alternate;
            pointer-events: none;
        }
        @keyframes pulse {
            from {
                opacity: 0.2;
                transform: scale(0.95);
            }
            to {
                opacity: 0.4;
                transform: scale(1.05);
            }
        }
        .health-pickup {
            position: absolute;
            background-color: #22c55e; /* green-500 */
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 15px #22c55e;
            animation: pulse-health 2s infinite alternate;
        }
        @keyframes pulse-health {
            from { transform: scale(0.9); }
            to { transform: scale(1.1); }
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center h-screen m-0">

    <div class="absolute top-5 left-5 z-20">
        <div id="wave-counter" class="text-2xl font-bold text-slate-400 mb-2"></div>
        <div id="health-bar-container">
            <div id="health-bar"></div>
        </div>
    </div>

    <div id="game-area">
         <div id="world-container">
            </div>
        
        <div id="joystick-base" class="absolute hidden w-24 h-24 bg-slate-500/30 rounded-full"></div>
        <div id="joystick-handle" class="absolute hidden w-12 h-12 bg-slate-400/50 rounded-full border-2 border-slate-300"></div>

        <div id="wave-cleared-message" class="absolute inset-0 flex items-center justify-center">Wave Cleared!</div>
    </div>

    <div id="start-modal" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-30">
        <div class="bg-slate-800 p-8 rounded-xl shadow-2xl text-center">
            <h2 class="text-3xl font-bold text-cyan-400 mb-4">Dungeon Shooter</h2>
            <div class="text-left text-slate-300 mb-6 p-4 bg-slate-700 rounded-lg">
                 <p class="mb-2"><kbd class="inline-block text-center w-24 px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Arrow Keys</kbd> to move.</p>
                 <p class="mb-2"><kbd class="inline-block text-center w-24 px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Mouse</kbd> to aim.</p>
                 <p><kbd class="inline-block text-center w-24 px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Click & Hold</kbd> to fire.</p>
                 <hr class="my-3 border-slate-600">
                 <p class="font-bold text-cyan-300 mb-2">Mobile Controls:</p>
                 <p class="mb-2"><kbd class="inline-block text-center w-24 px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Touch Player</kbd> to move.</p>
                 <p class="mb-2"><kbd class="inline-block text-center w-24 px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Tap Away</kbd> to shoot.</p>
                 <p><kbd class="inline-block text-center w-24 px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Swipe Away</kbd> to dodge.</p>
            </div>
            <button id="start-game-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg transition-colors text-lg">
                Enter Dungeon
            </button>
        </div>
    </div>
    
    <div id="game-over-modal" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-30">
        <div class="bg-slate-800 p-8 rounded-xl shadow-2xl text-center">
            <h2 class="text-3xl font-bold text-red-500 mb-4">You Have Perished</h2>
            <p class="text-slate-300 mb-6">The dungeon claims another soul.</p>
            <button id="play-again-lose-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                Try Again
            </button>
        </div>
    </div>

    <script>
        // Get the sphere and game area elements from the DOM
        let sphere, turret; // These are created dynamically now
        const gameArea = document.getElementById('game-area');
        const worldContainer = document.getElementById('world-container');
        const startModal = document.getElementById('start-modal');
        const startGameBtn = document.getElementById('start-game-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const playAgainLoseBtn = document.getElementById('play-again-lose-btn');
        const waveCounter = document.getElementById('wave-counter');
        const waveClearedMessage = document.getElementById('wave-cleared-message');
        const healthBar = document.getElementById('health-bar');
        const joystickBase = document.getElementById('joystick-base');
        const joystickHandle = document.getElementById('joystick-handle');


        // --- Configuration ---
        const VIRTUAL_WIDTH = 1800; // The desired horizontal resolution of the game
        const playerSpeed = 8;
        const bulletSpeed = 32;
        const enemyBulletSpeed = bulletSpeed / 4; 
        const baseEnemyCount = 0; 
        const enemyRadius = 20;
        const bulletRadius = 5;
        const playerRadius = 20;
        const baseEnemySpeed = playerSpeed / 2;
        const pathfindingUpdateRate = 500; 
        const fireChargeTime = 80; 
        const playerFireCooldownTime = ((fireChargeTime / 10) * 3) / 1.5;
        const maxPlayerHealth = 100;
        const enemyBulletDamage = 20;
        const enemyChaserDamage = 30;
        const dodgeSpeed = playerSpeed * 3;
        const dodgeDuration = 8; // frames
        const dodgeCooldownTime = 60; // frames
        const gridSize = enemyRadius * 2;
        const gridWidth = 50;
        const gridHeight = 50;
        const healthPickupValue = 50;
        const healthPickupDropChance = 1 / 3;
        const healthRegenRate = 40; // frames per 1 hp
        const healthRegenAmount = 1;

        // --- Touch Control Configuration ---
        const SWIPE_DURATION = 300;     // ms: Max duration for a swipe
        const SWIPE_DISTANCE = 50;      // px: Min distance for a swipe
        const JOYSTICK_ACTIVATION_RADIUS = playerRadius * 4;

        // --- State ---
        let player; 
        let bullets = [];
        let enemyBullets = [];
        let enemies = [];
        let walls = [];
        let healthPickups = [];
        let grid = [];
        let loopCounter = 0;
        let pathDots = [];
        let currentWave = 0;
        let isWaveTransitioning = false;
        let gameStarted = false; 
        let playerFireCooldown = 0;
        let isMouseDown = false;
        let mousePos = { x: 0, y: 0 };
        let isDodging = 0;
        let dodgeCooldown = 0;
        let fogs = [], cobwebs = [], skeletons = [];
        
        // --- Touch State ---
        let activeTouches = new Map();
        let movementTouchId = null;
        let joystickBasePos = { x: 0, y: 0 };
        let playerMoveVector = { x: 0, y: 0 };
        
        // --- Camera State ---
        let camera = { x: 0, y: 0 };
        let worldWidth = gridSize * gridWidth;
        let worldHeight = gridSize * gridHeight;


        const keysPressed = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false
        };

        // --- A* Pathfinding Node ---
        class Node {
            constructor(x, y) {
                this.x = x; this.y = y; this.isWall = false;
                this.gCost = 0; this.hCost = 0; this.fCost = 0;
                this.parent = null;
            }
        }

        function createGrid() {
            grid = [];
            for (let y = 0; y < gridHeight; y++) {
                grid[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    grid[y][x] = new Node(x, y);
                }
            }
        }

        function getNodeFromWorldPoint(x, y) {
            const gridX = Math.floor(x / gridSize);
            const gridY = Math.floor(y / gridSize);
            if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                return grid[gridY][gridX];
            }
            return null;
        }
        
        // --- Game Setup ---
        function startNewWave() {
            isWaveTransitioning = false;
            currentWave++;
            waveCounter.textContent = `Wave: ${currentWave}`;
            const enemyCountForWave = (baseEnemyCount + currentWave) * 2;
            spawnEnemies(enemyCountForWave);
        }

        function showWaveCleared() {
            isWaveTransitioning = true;
            waveClearedMessage.style.display = 'flex';
            setTimeout(() => {
                waveClearedMessage.style.display = 'none';
                startNewWave();
            }, 2000); // Duration of the message
        }
        
        function createPlayer() {
            const playerEl = document.createElement('div');
            playerEl.id = 'sphere';
            playerEl.className = 'w-10 h-10 bg-cyan-400 rounded-full shadow-lg shadow-cyan-400/50';
            const turretEl = document.createElement('div');
            turretEl.id = 'turret';
            playerEl.appendChild(turretEl);
            worldContainer.appendChild(playerEl);
            sphere = playerEl;
            turret = turretEl;
        }

        function spawnHealthPickup(x, y) {
            const pickupRadius = 12;
            const pickup = {
                element: document.createElement('div'), x: x, y: y, radius: pickupRadius,
            };
            pickup.element.className = 'health-pickup';
            worldContainer.appendChild(pickup.element);
            healthPickups.push(pickup);
        }

        function spawnEnemies(count) {
            enemies.forEach(e => e.element.remove());
            enemies = [];
            const playerNode = player ? getNodeFromWorldPoint(player.x, player.y) : null;
            const minSpawnDist = 10; 

            for(let i = 0; i < count; i++) {
                let validPosition = false;
                let spawnNode;
                let attempts = 0;
                while(!validPosition && attempts < gridWidth * gridHeight * 2) {
                    const gridX = Math.floor(Math.random() * gridWidth);
                    const gridY = Math.floor(Math.random() * gridHeight);
                    spawnNode = grid[gridY][gridX];
                    const distToPlayer = playerNode ? Math.hypot(gridX - playerNode.x, gridY - playerNode.y) : Infinity;
                    if (!spawnNode.isWall && distToPlayer >= minSpawnDist) validPosition = true;
                    attempts++;
                }
                if (!spawnNode) spawnNode = grid[0][0];

                const enemyType = Math.random() < 0.3 ? 'chaser' : 'shooter';
                const newEnemy = {
                    element: document.createElement('div'),
                    x: spawnNode.x * gridSize + enemyRadius, y: spawnNode.y * gridSize + enemyRadius,
                    radius: enemyRadius, path: [], targetNode: null, type: enemyType,
                    speed: enemyType === 'chaser' ? baseEnemySpeed * 1.5 : baseEnemySpeed,
                    lastGridPos: { x: -1, y: -1 }, stuckCounter: 0,
                };

                if (newEnemy.type === 'shooter') {
                    newEnemy.turretElement = document.createElement('div');
                    newEnemy.chargeTimer = 0;
                    newEnemy.element.className = 'enemy';
                    newEnemy.turretElement.className = 'enemy-turret';
                    newEnemy.element.appendChild(newEnemy.turretElement);
                } else {
                     newEnemy.element.className = 'enemy-chaser';
                }
                worldContainer.appendChild(newEnemy.element);
                enemies.push(newEnemy);
            }
        }
        
        function spawnFog() {
            const FOG_COUNT = 150;
            for (let i = 0; i < FOG_COUNT; i++) {
                const size = (Math.random() * 0.4 + 0.1) * Math.min(worldWidth, worldHeight);
                const fog = {
                    element: document.createElement('div'),
                    x: Math.random() * worldWidth - size / 2,
                    y: Math.random() * worldHeight - size / 2,
                    size: size
                };
                fog.element.className = 'fog';
                fog.element.style.animationDelay = `${Math.random() * -20}s`;
                fog.element.style.animationDuration = `${Math.random() * 20 + 15}s`;
                worldContainer.appendChild(fog.element);
                fogs.push(fog);
            }
        }

        function isMapValid() {
            let firstOpenNode = null, totalOpenNodes = 0;
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (!grid[y][x].isWall) {
                        totalOpenNodes++;
                        if (!firstOpenNode) firstOpenNode = grid[y][x];
                    }
                }
            }
            if (!firstOpenNode) return true; 

            const queue = [firstOpenNode];
            const visited = new Set([`${firstOpenNode.x},${firstOpenNode.y}`]);
            let reachableCount = 0;
            while (queue.length > 0) {
                const currentNode = queue.shift();
                reachableCount++;
                for (let y = -1; y <= 1; y++) {
                    for (let x = -1; x <= 1; x++) {
                        if (x === 0 && y === 0) continue;
                        const checkX = currentNode.x + x, checkY = currentNode.y + y;
                        if (checkX >= 0 && checkX < gridWidth && checkY >= 0 && checkY < gridHeight) {
                            const neighbor = grid[checkY][checkX];
                            const neighborId = `${neighbor.x},${neighbor.y}`;
                            if (!neighbor.isWall && !visited.has(neighborId)) {
                                visited.add(neighborId);
                                queue.push(neighbor);
                            }
                        }
                    }
                }
            }
            return reachableCount === totalOpenNodes;
        }

        function spawnWalls() {
            let attempt = 0;
            const MAX_ATTEMPTS = 50;
            do {
                walls.forEach(w => w.element.remove());
                walls = [];
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) grid[y][x].isWall = false;
                }
                const wallDefs = [
                    { x: 0, y: 0, width: worldWidth, height: gridSize }, 
                    { x: 0, y: worldHeight - gridSize, width: worldWidth, height: gridSize },
                    { x: 0, y: 0, width: gridSize, height: worldHeight }, 
                    { x: worldWidth - gridSize, y: 0, width: gridSize, height: worldHeight }
                ];
                wallDefs.forEach(def => {
                    const wall = { element: document.createElement('div'), ...def };
                    wall.element.className = 'wall';
                    worldContainer.appendChild(wall.element);
                    walls.push(wall);
                    const startGridX = Math.max(0, Math.floor(def.x / gridSize));
                    const endGridX = Math.min(gridWidth, Math.ceil((def.x + def.width) / gridSize));
                    const startGridY = Math.max(0, Math.floor(def.y / gridSize));
                    const endGridY = Math.min(gridHeight, Math.ceil((def.y + def.height) / gridSize));
                    for(let y = startGridY; y < endGridY; y++) {
                        for(let x = startGridX; x < endGridX; x++) {
                             if (x < gridWidth && y < gridHeight) grid[y][x].isWall = true;
                        }
                    }
                });
                const wallCount = 165;
                const maxWallLength = 16;
                for (let i = 0; i < wallCount; i++) {
                    const length = Math.floor(Math.random() * (maxWallLength - 2)) + 3;
                    const isHorizontal = Math.random() > 0.5;
                    let startGridX, startGridY, endGridX, endGridY;
                    if (isHorizontal) {
                        startGridX = Math.floor(Math.random() * (gridWidth - length));
                        startGridY = Math.floor(Math.random() * (gridHeight - 2)) + 1;
                        endGridX = startGridX + length;
                        endGridY = startGridY + 1;
                    } else {
                        startGridX = Math.floor(Math.random() * (gridWidth - 2)) + 1;
                        startGridY = Math.floor(Math.random() * (gridHeight - length));
                        endGridX = startGridX + 1;
                        endGridY = startGridY + length;
                    }
                    let canPlace = true;
                    for (let y = startGridY; y < endGridY; y++) {
                        for (let x = startGridX; x < endGridX; x++) {
                            if (y < gridHeight && x < gridWidth && grid[y][x].isWall) {
                                canPlace = false; break;
                            }
                        }
                        if (!canPlace) break;
                    }
                    if (canPlace) {
                         const wall = {
                            element: document.createElement('div'),
                            x: startGridX * gridSize, y: startGridY * gridSize,
                            width: (endGridX - startGridX) * gridSize,
                            height: (endGridY - startGridY) * gridSize,
                        };
                        wall.element.className = 'wall';
                        worldContainer.appendChild(wall.element);
                        walls.push(wall);
                        for (let y = startGridY; y < endGridY; y++) {
                            for (let x = startGridX; x < endGridX; x++) {
                                 if (y < gridHeight && x < gridWidth) grid[y][x].isWall = true;
                            }
                        }
                    }
                }
                attempt++;
            } while (!isMapValid() && attempt < MAX_ATTEMPTS);
            spawnCobwebs();
            spawnSkeletons();
            if (attempt >= MAX_ATTEMPTS) console.warn("Could not generate a valid map.");
        }

        function spawnCobwebs() {
            const cobwebSVG = `<svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none"><g stroke="rgba(200,200,200,0.15)" stroke-width="2" fill="none"><line x1="0" y1="0" x2="100" y2="0" /><line x1="0" y1="0" x2="86.6" y2="50" /><line x1="0" y1="0" x2="50" y2="86.6" /><line x1="0" y1="0" x2="0" y2="100" /><path d="M 100 0 A 100 100 0 0 0 0 100" /><path d="M 75 0 A 75 75 0 0 0 0 75" /><path d="M 50 0 A 50 50 0 0 0 0 50" /><path d="M 25 0 A 25 25 0 0 0 0 25" /></g></svg>`;
            const COBWEB_COUNT = 300;
            const corners = [];
            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 1; x < gridWidth - 1; x++) {
                    if (!grid[y][x].isWall) {
                        if (grid[y - 1][x].isWall && grid[y][x - 1].isWall) corners.push({ x, y, type: 'TL' });
                        if (grid[y - 1][x].isWall && grid[y][x + 1].isWall) corners.push({ x, y, type: 'TR' });
                        if (grid[y + 1][x].isWall && grid[y][x - 1].isWall) corners.push({ x, y, type: 'BL' });
                        if (grid[y + 1][x].isWall && grid[y][x + 1].isWall) corners.push({ x, y, type: 'BR' });
                    }
                }
            }
            corners.sort(() => 0.5 - Math.random());
            const cornersToDraw = corners.slice(0, COBWEB_COUNT);
            cornersToDraw.forEach(corner => {
                const web = {
                    element: document.createElement('div'),
                    x: corner.x * gridSize, y: corner.y * gridSize
                };
                web.element.style.position = 'absolute';
                web.element.style.pointerEvents = 'none';
                let transform = '';
                switch (corner.type) {
                    case 'TR': transform = 'scale(-1, 1)'; break;
                    case 'BL': transform = 'scale(1, -1)'; break;
                    case 'BR': transform = 'scale(-1, -1)'; break;
                }
                web.element.style.transform = transform;
                web.element.innerHTML = cobwebSVG;
                worldContainer.appendChild(web.element);
                cobwebs.push(web);
            });
        }
        function spawnSkeletons() {
            const skeletonSVG = `<svg width="100%" height="100%" viewBox="0 0 40 40"><g stroke="rgba(226, 232, 240, 0.4)" stroke-width="2" fill="none" stroke-linecap="round"><circle cx="20" cy="8" r="4" /><line x1="20" y1="12" x2="20" y2="28" /><line x1="14" y1="16" x2="26" y2="16" /><line x1="14" y1="20" x2="26" y2="20" /><line x1="15" y1="24" x2="25" y2="24" /><line x1="14" y1="16" x2="8" y2="12" /><line x1="26" y1="16" x2="32" y2="12" /><line x1="20" y1="28" x2="14" y2="34" /><line x1="20" y1="28" x2="26" y2="34" /></g></svg>`;
            const SKELETON_COUNT = 25;
            const floorTiles = [];
            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 1; x < gridWidth - 1; x++) {
                    if (!grid[y][x].isWall) floorTiles.push({ x, y });
                }
            }
            floorTiles.sort(() => 0.5 - Math.random());
            const tilesToDraw = floorTiles.slice(0, SKELETON_COUNT);
            tilesToDraw.forEach(tile => {
                const skeleton = {
                    element: document.createElement('div'),
                    x: tile.x * gridSize, y: tile.y * gridSize
                };
                skeleton.element.style.position = 'absolute';
                skeleton.element.style.pointerEvents = 'none';
                skeleton.element.style.transform = `rotate(${Math.random() * 360}deg)`;
                skeleton.element.innerHTML = skeletonSVG;
                worldContainer.appendChild(skeleton.element);
                skeletons.push(skeleton);
            });
        }

        function createExplosion(x, y, radius, color) {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            const scale = gameArea.clientWidth / VIRTUAL_WIDTH;
            ripple.style.left = `${(x - radius - camera.x) * scale}px`;
            ripple.style.top = `${(y - radius - camera.y) * scale}px`;
            ripple.style.width = `${(radius * 2) * scale}px`;
            ripple.style.height = `${(radius * 2) * scale}px`;
            ripple.style.boxShadow = `0 0 0 ${4 * scale}px ${color}`;
            gameArea.appendChild(ripple);
            setTimeout(() => ripple.remove(), 170);
        }
        
        function hasLineOfSight(startX, startY, endX, endY) {
            const dx = endX - startX, dy = endY - startY;
            const distance = Math.hypot(dx, dy);
            const step = gridSize / 4; 
            const steps = Math.floor(distance / step);
            if (steps <= 1) return true;
            for (let i = 1; i < steps; i++) {
                const currentX = startX + (dx * i) / steps;
                const currentY = startY + (dy * i) / steps;
                for (const wall of walls) {
                    if (currentX >= wall.x && currentX <= wall.x + wall.width &&
                        currentY >= wall.y && currentY <= wall.y + wall.height) return false;
                }
            }
            return true;
        }
        
        function screenToWorld(screenX, screenY) {
            const scale = gameArea.clientWidth / VIRTUAL_WIDTH;
            const worldX = (screenX / scale) + camera.x;
            const worldY = (screenY / scale) + camera.y;
            return { x: worldX, y: worldY };
        }

        function firePlayerBullet(targetX, targetY) {
            if (!player) return;
            const worldCoords = screenToWorld(targetX, targetY);
            const angle = Math.atan2(worldCoords.y - player.y, worldCoords.x - player.x);
            const bullet = {
                element: document.createElement('div'), x: player.x, y: player.y,
                dx: Math.cos(angle) * bulletSpeed, dy: Math.sin(angle) * bulletSpeed, radius: bulletRadius
            };
            bullet.element.className = 'bullet';
            worldContainer.appendChild(bullet.element);
            bullets.push(bullet);
            playerFireCooldown = playerFireCooldownTime;
        }

        function fireEnemyBullet(enemy) {
            if (!player) return;
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            const bullet = {
                element: document.createElement('div'), x: enemy.x, y: enemy.y,
                dx: Math.cos(angle) * enemyBulletSpeed, dy: Math.sin(angle) * enemyBulletSpeed, radius: bulletRadius
            };
            bullet.element.className = 'enemy-bullet';
            worldContainer.appendChild(bullet.element);
            enemyBullets.push(bullet);
        }

        function findPath(startNode, targetNode) {
            if (!startNode || !targetNode || startNode.isWall || targetNode.isWall) return [];
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    grid[y][x].gCost = 0; grid[y][x].hCost = 0;
                    grid[y][x].fCost = 0; grid[y][x].parent = null;
                }
            }
            const openList = [startNode];
            const closedList = new Set();
            while(openList.length > 0) {
                let currentNode = openList[0];
                for(let i = 1; i < openList.length; i++) {
                    if (openList[i].fCost < currentNode.fCost || (openList[i].fCost === currentNode.fCost && openList[i].hCost < currentNode.hCost)) {
                        currentNode = openList[i];
                    }
                }
                openList.splice(openList.indexOf(currentNode), 1);
                closedList.add(currentNode);
                if (currentNode === targetNode) {
                    const path = [];
                    let pathNode = targetNode;
                    while(pathNode !== startNode && pathNode.parent) {
                        path.push(pathNode);
                        pathNode = pathNode.parent;
                    }
                    return path.reverse();
                }
                for (let y = -1; y <= 1; y++) {
                    for (let x = -1; x <= 1; x++) {
                        if (Math.abs(x) === Math.abs(y)) continue; 
                        const checkX = currentNode.x + x;
                        const checkY = currentNode.y + y;
                        if (checkX >= 0 && checkX < gridWidth && checkY >= 0 && checkY < gridHeight) {
                            const neighbor = grid[checkY][checkX];
                            if (neighbor.isWall || closedList.has(neighbor)) continue;
                            const newMovementCost = currentNode.gCost + (Math.abs(x) + Math.abs(y) > 1 ? 14 : 10);
                            if (newMovementCost < neighbor.gCost || !openList.includes(neighbor)) {
                                neighbor.gCost = newMovementCost;
                                neighbor.hCost = Math.abs(neighbor.x - targetNode.x) + Math.abs(neighbor.y - targetNode.y);
                                neighbor.fCost = neighbor.gCost + neighbor.hCost;
                                neighbor.parent = currentNode;
                                if (!openList.includes(neighbor)) openList.push(neighbor);
                            }
                        }
                    }
                }
            }
            return [];
        }

        function setNewPathForEnemy(enemy, isAggro = false) {
            const startNode = getNodeFromWorldPoint(enemy.x, enemy.y);
            if (!startNode) return;
            let targetNode;
            if (isAggro && player) {
                 targetNode = getNodeFromWorldPoint(player.x, player.y);
            } else {
                if (enemies.length < 5) { 
                    let attempts = 0;
                    const MAX_ATTEMPTS = 100;
                    do {
                        const scale = gameArea.clientWidth / VIRTUAL_WIDTH;
                        const viewableWorldWidth = gameArea.clientWidth / scale;
                        const viewableWorldHeight = gameArea.clientHeight / scale;
                        const startGridX = Math.max(0, Math.floor(camera.x / gridSize));
                        const startGridY = Math.max(0, Math.floor(camera.y / gridSize));
                        const endGridX = Math.min(gridWidth - 1, Math.floor((camera.x + viewableWorldWidth) / gridSize));
                        const endGridY = Math.min(gridHeight - 1, Math.floor((camera.y + viewableWorldHeight) / gridSize));
                        if (startGridX >= endGridX || startGridY >= endGridY) {
                            targetNode = null; break;
                        }
                        const randX = Math.floor(Math.random() * (endGridX - startGridX + 1)) + startGridX;
                        const randY = Math.floor(Math.random() * (endGridY - startGridY + 1)) + startGridY;
                        targetNode = grid[randY][randX];
                        attempts++;
                    } while (attempts < MAX_ATTEMPTS && (!targetNode || targetNode.isWall));
                    if (!targetNode || targetNode.isWall) {
                        do { targetNode = grid[Math.floor(Math.random() * gridHeight)][Math.floor(Math.random() * gridWidth)]; } 
                        while(targetNode && targetNode.isWall);
                    }
                } else {
                     do { targetNode = grid[Math.floor(Math.random() * gridHeight)][Math.floor(Math.random() * gridWidth)]; } 
                     while(targetNode && targetNode.isWall);
                }
            }
            if(targetNode) enemy.path = findPath(startNode, targetNode);
        }

        function resetGame() {
            gameOverModal.style.display = 'none';
            worldContainer.innerHTML = '';
            
            bullets = []; enemyBullets = []; healthPickups = [];
            fogs = []; cobwebs = []; skeletons = [];
            
            createPlayer();
            createGrid();
            spawnWalls();
            spawnFog();
            
            player = { 
                x: worldWidth / 2, y: worldHeight / 2, radius: playerRadius,
                health: maxPlayerHealth, dodgeVector: {x: 0, y: 0}
            };
            playerFireCooldown = 0; dodgeCooldown = 0; isDodging = 0;
            currentWave = 0;
            startNewWave();
        }

        document.addEventListener('keydown', (e) => { if(keysPressed.hasOwnProperty(e.key)) { e.preventDefault(); keysPressed[e.key] = true; }});
        document.addEventListener('keyup', (e) => { if(keysPressed.hasOwnProperty(e.key)) { e.preventDefault(); keysPressed[e.key] = false; }});
        window.addEventListener('mousemove', (e) => { mousePos = { x: e.clientX, y: e.clientY }; });
        window.addEventListener('mousedown', (e) => { if (e.target.tagName !== 'BUTTON') isMouseDown = true; });
        window.addEventListener('mouseup', () => { isMouseDown = false; });
        gameArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (movementTouchId === null && player) {
                    const scale = gameArea.clientWidth / VIRTUAL_WIDTH;
                    const playerScreenX = (player.x - camera.x) * scale;
                    const playerScreenY = (player.y - camera.y) * scale;
                    if (Math.hypot(touch.clientX - playerScreenX, touch.clientY - playerScreenY) < JOYSTICK_ACTIVATION_RADIUS * scale) {
                        movementTouchId = touch.identifier;
                        joystickBasePos = { x: touch.clientX, y: touch.clientY };
                        joystickBase.style.display = 'block';
                        joystickHandle.style.display = 'block';
                        joystickBase.style.left = `${joystickBasePos.x - joystickBase.offsetWidth / 2}px`;
                        joystickBase.style.top = `${joystickBasePos.y - joystickBase.offsetHeight / 2}px`;
                        joystickHandle.style.left = `${joystickBasePos.x - joystickHandle.offsetWidth / 2}px`;
                        joystickHandle.style.top = `${joystickBasePos.y - joystickHandle.offsetHeight / 2}px`;
                        continue;
                    }
                }
                activeTouches.set(touch.identifier, {
                    startTime: Date.now(),
                    startX: touch.clientX,
                    startY: touch.clientY,
                });
            }
        });
        gameArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === movementTouchId) {
                    const maxDist = joystickBase.offsetWidth / 2;
                    const dx = touch.clientX - joystickBasePos.x, dy = touch.clientY - joystickBasePos.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > maxDist) {
                        playerMoveVector = { x: (dx / dist), y: (dy / dist) };
                        joystickHandle.style.left = `${joystickBasePos.x + playerMoveVector.x * maxDist - joystickHandle.offsetWidth / 2}px`;
                        joystickHandle.style.top = `${joystickBasePos.y + playerMoveVector.y * maxDist - joystickHandle.offsetHeight / 2}px`;
                    } else {
                        playerMoveVector = { x: dx / maxDist, y: dy / maxDist };
                        joystickHandle.style.left = `${touch.clientX - joystickHandle.offsetWidth / 2}px`;
                        joystickHandle.style.top = `${touch.clientY - joystickHandle.offsetHeight / 2}px`;
                    }
                }
            }
        });
        gameArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === movementTouchId) {
                    movementTouchId = null;
                    playerMoveVector = { x: 0, y: 0 };
                    joystickBase.style.display = 'none';
                    joystickHandle.style.display = 'none';
                }
                if (activeTouches.has(touch.identifier)) {
                    const touchData = activeTouches.get(touch.identifier);
                    const duration = Date.now() - touchData.startTime;
                    const dist = Math.hypot(touch.clientX - touchData.startX, touch.clientY - touchData.startY);
                    if (duration <= SWIPE_DURATION && dist >= SWIPE_DISTANCE) {
                        if (player && dodgeCooldown <= 0) {
                            isDodging = dodgeDuration;
                            dodgeCooldown = dodgeCooldownTime;
                            const worldStart = screenToWorld(touchData.startX, touchData.startY);
                            const worldEnd = screenToWorld(touch.clientX, touch.clientY);
                            const angle = Math.atan2(worldEnd.y - worldStart.y, worldEnd.x - worldStart.x);
                            player.dodgeVector = { x: Math.cos(angle), y: Math.sin(angle) };
                        }
                    } else {
                        if (player && playerFireCooldown <= 0 && !isWaveTransitioning) {
                            firePlayerBullet(touch.clientX, touch.clientY);
                        }
                    }
                    activeTouches.delete(touch.identifier);
                }
            }
        });
        
        startGameBtn.addEventListener('click', () => {
            startModal.style.display = 'none';
            resetGame();
            if (!gameStarted) {
                gameLoop();
                gameStarted = true;
            }
        });

        playAgainLoseBtn.addEventListener('click', () => {
            gameOverModal.style.display = 'none';
            startModal.style.display = 'flex';
        });

        function createDodgeTrail(x, y) {
            const trail = document.createElement('div');
            const scale = gameArea.clientWidth / VIRTUAL_WIDTH;
            trail.className = 'dodge-indicator';
            trail.style.left = `${(x - 5 - camera.x) * scale}px`;
            trail.style.top = `${(y - 5 - camera.y) * scale}px`;
            trail.style.width = `${10 * scale}px`;
            trail.style.height = `${10 * scale}px`;
            gameArea.appendChild(trail);
            setTimeout(() => trail.remove(), 300);
        }

        function gameLoop() {
            if (startModal.style.display !== 'none' || gameOverModal.style.display === 'flex') {
                requestAnimationFrame(gameLoop);
                return;
            }
            loopCounter++;

            // --- 1. Player Movement & Logic ---
            if (player) {
                if (playerFireCooldown > 0) playerFireCooldown--;
                if (dodgeCooldown > 0) dodgeCooldown--;
                if (loopCounter % healthRegenRate === 0 && player.health < maxPlayerHealth) {
                    player.health = Math.min(maxPlayerHealth, player.health + healthRegenAmount);
                }
                if (isDodging > 0) {
                    player.x += player.dodgeVector.x * dodgeSpeed;
                    player.y += player.dodgeVector.y * dodgeSpeed;
                    isDodging--;
                    createDodgeTrail(player.x, player.y);
                } else {
                    let keyDx = 0, keyDy = 0;
                    if (keysPressed.ArrowUp) keyDy -= 1; if (keysPressed.ArrowDown) keyDy += 1;
                    if (keysPressed.ArrowLeft) keyDx -= 1; if (keysPressed.ArrowRight) keyDx += 1;
                    let finalDx = playerMoveVector.x + keyDx;
                    let finalDy = playerMoveVector.y + keyDy;
                    const magnitude = Math.hypot(finalDx, finalDy);
                    if (magnitude > 0) {
                        const moveX = (finalDx / magnitude) * Math.min(magnitude, 1);
                        const moveY = (finalDy / magnitude) * Math.min(magnitude, 1);
                        player.x += moveX * playerSpeed;
                        player.y += moveY * playerSpeed;
                    }
                }
                // Aiming
                const worldCoords = screenToWorld(mousePos.x, mousePos.y);
                const turretAngle = Math.atan2(worldCoords.y - player.y, worldCoords.x - player.x);
                turret.style.transform = `rotate(${turretAngle * 180 / Math.PI}deg)`;
                // Shooting
                if (isMouseDown && playerFireCooldown <= 0 && !isWaveTransitioning) {
                    firePlayerBullet(mousePos.x, mousePos.y);
                }
            }
            
            // --- 2. Enemy AI & Movement ---
            if (loopCounter % pathfindingUpdateRate === 0 && enemies.length > 0) {
                 enemies.forEach((enemy) => {
                    const isAggro = (enemy.type === 'chaser' && player) || (enemy.type === 'shooter' && Math.random() < 0.5);
                    setNewPathForEnemy(enemy, isAggro);
                 });
            }
            enemies.forEach((enemy) => {
                const currentGridNode = getNodeFromWorldPoint(enemy.x, enemy.y);
                if (currentGridNode) {
                    if (currentGridNode.x === enemy.lastGridPos.x && currentGridNode.y === enemy.lastGridPos.y) enemy.stuckCounter++;
                    else { enemy.stuckCounter = 0; enemy.lastGridPos = { x: currentGridNode.x, y: currentGridNode.y }; }
                    if (enemy.stuckCounter > 20) { setNewPathForEnemy(enemy, false); enemy.stuckCounter = 0; }
                }
                if (enemy.path && enemy.path.length > 0) {
                    const nextNode = enemy.path[0];
                    const targetX = nextNode.x * gridSize + enemyRadius;
                    const targetY = nextNode.y * gridSize + enemyRadius;
                    const moveDx = targetX - enemy.x, moveDy = targetY - enemy.y;
                    const dist = Math.hypot(moveDx, moveDy);
                    if (dist > enemy.speed) {
                        enemy.x += (moveDx / dist) * enemy.speed;
                        enemy.y += (moveDy / dist) * enemy.speed;
                    } else {
                        enemy.x = targetX;
                        enemy.y = targetY;
                        enemy.path.shift();
                        if (enemy.path.length === 0) setNewPathForEnemy(enemy, enemy.type === 'chaser' || Math.random() < 0.5);
                    }
                } else if (player) {
                    setNewPathForEnemy(enemy, enemy.type === 'chaser' || Math.random() < 0.5);
                }
                if (player && !isWaveTransitioning && enemy.type === 'shooter') {
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.turretElement.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
                    if (hasLineOfSight(enemy.x, enemy.y, player.x, player.y)) {
                        enemy.chargeTimer = Math.min(fireChargeTime, enemy.chargeTimer + 1);
                        const chargeRatio = enemy.chargeTimer / fireChargeTime;
                        const r = 251 + (239 - 251) * chargeRatio, g = 191 + (68 - 191) * chargeRatio, b = 36 + (68 - 36) * chargeRatio;
                        enemy.turretElement.style.backgroundColor = `rgb(${r},${g},${b})`;
                        if (enemy.chargeTimer === fireChargeTime) { fireEnemyBullet(enemy); enemy.chargeTimer = 0; }
                    } else {
                        enemy.chargeTimer = 0;
                        enemy.turretElement.style.backgroundColor = '#fca5a5';
                    }
                }
            });

            // --- 3. Collision Detection & Resolution ---
            if (player) {
                for (let i = healthPickups.length - 1; i >= 0; i--) {
                    const pickup = healthPickups[i];
                    if (Math.hypot(player.x - pickup.x, player.y - pickup.y) < player.radius + pickup.radius) {
                        player.health = Math.min(maxPlayerHealth, player.health + healthPickupValue);
                        createExplosion(pickup.x, pickup.y, pickup.radius, '#22c55e');
                        pickup.element.remove();
                        healthPickups.splice(i, 1);
                    }
                }
                walls.forEach(wall => {
                    const closestX = Math.max(wall.x, Math.min(player.x, wall.x + wall.width));
                    const closestY = Math.max(wall.y, Math.min(player.y, wall.y + wall.height));
                    const dist = Math.hypot(player.x - closestX, player.y - closestY);
                    if (dist < player.radius) {
                        const overlap = player.radius - dist;
                        const angle = Math.atan2(player.y - closestY, player.x - closestX);
                        player.x += overlap * Math.cos(angle);
                        player.y += overlap * Math.sin(angle);
                    }
                });
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    const min_dist = player.radius + enemy.radius;
                    if (dist < min_dist) {
                        if (enemy.type === 'chaser') {
                            if (isDodging <= 0) player.health -= enemyChaserDamage;
                            createExplosion(enemy.x, enemy.y, enemy.radius, '#f59e0b');
                            enemy.element.remove(); enemies.splice(i, 1);
                             if (player.health <= 0) {
                                createExplosion(player.x, player.y, player.radius, '#67e8f9');
                                if(sphere) sphere.style.display = 'none';
                                player = null; 
                                setTimeout(() => gameOverModal.style.display = 'flex', 100);
                                return;
                            }
                        } else {
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            const overlap = min_dist - dist;
                            player.x += overlap * Math.cos(angle);
                            player.y += overlap * Math.sin(angle);
                        }
                    }
                }
                player.x = Math.max(player.radius, Math.min(worldWidth - player.radius, player.x));
                player.y = Math.max(player.radius, Math.min(worldHeight - player.radius, player.y));
            }
            enemies.forEach(enemy => {
                walls.forEach(wall => {
                    const closestX = Math.max(wall.x, Math.min(enemy.x, wall.x + wall.width));
                    const closestY = Math.max(wall.y, Math.min(enemy.y, wall.y + wall.height));
                    if (Math.hypot(enemy.x - closestX, enemy.y - closestY) < enemy.radius) {
                        const overlap = enemy.radius - (Math.hypot(enemy.x - closestX, enemy.y - closestY));
                        const angle = Math.atan2(enemy.y - closestY, enemy.x - closestX);
                        enemy.x += overlap * Math.cos(angle);
                        enemy.y += overlap * Math.sin(angle);
                    }
                });
            });

            // --- 4. Bullet Movement & Collision ---
            [bullets, enemyBullets].forEach((bulletList, listIndex) => {
                for (let i = bulletList.length - 1; i >= 0; i--) {
                    const bullet = bulletList[i];
                    bullet.x += bullet.dx; bullet.y += bullet.dy;
                    let hit = false;
                    for (const wall of walls) {
                        if (Math.hypot(bullet.x - Math.max(wall.x, Math.min(bullet.x, wall.x + wall.width)), bullet.y - Math.max(wall.y, Math.min(bullet.y, wall.y + wall.height))) < bullet.radius) { hit = true; break; }
                    }
                    if (hit) { createExplosion(bullet.x, bullet.y, bullet.radius, listIndex === 0 ? 'white' : '#f87171'); bullet.element.remove(); bulletList.splice(i, 1); continue; }
                    if (listIndex === 0) {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            if (Math.hypot(bullet.x - enemies[j].x, bullet.y - enemies[j].y) < bullet.radius + enemies[j].radius) {
                                createExplosion(enemies[j].x, enemies[j].y, enemies[j].radius, enemies[j].type === 'shooter' ? '#b91c1c' : '#f59e0b');
                                if (Math.random() < healthPickupDropChance) spawnHealthPickup(enemies[j].x, enemies[j].y);
                                enemies[j].element.remove(); enemies.splice(j, 1);
                                hit = true;
                                if(enemies.length === 0 && !isWaveTransitioning) showWaveCleared();
                                break;
                            }
                        }
                    } else {
                        if (player && Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.radius) {
                            if (isDodging <= 0) {
                                player.health -= enemyBulletDamage;
                                hit = true;
                                if (player.health <= 0) {
                                    createExplosion(player.x, player.y, player.radius, '#67e8f9');
                                    if(sphere) sphere.style.display = 'none';
                                    player = null; 
                                    setTimeout(() => gameOverModal.style.display = 'flex', 100);
                                }
                            }
                        }
                    }
                    if (hit) { createExplosion(bullet.x, bullet.y, bullet.radius, listIndex === 0 ? 'white' : '#f87171'); bullet.element.remove(); bulletList.splice(i, 1); continue; }
                    if (bullet.x < 0 || bullet.x > worldWidth || bullet.y < 0 || bullet.y > worldHeight) { bullet.element.remove(); bulletList.splice(i, 1); }
                }
            });

            // --- 5. Render all objects ---
            if(player) {
                const scale = gameArea.clientWidth / VIRTUAL_WIDTH;
                const viewableWorldHeight = gameArea.clientHeight / scale;

                camera.x = player.x - (VIRTUAL_WIDTH / 2);
                camera.y = player.y - (viewableWorldHeight / 2);
                camera.x = Math.max(0, Math.min(worldWidth - VIRTUAL_WIDTH, camera.x));
                camera.y = Math.max(0, Math.min(worldHeight - viewableWorldHeight, camera.y));
                
                // Render Player
                const playerSize = player.radius * 2 * scale;
                sphere.style.left = `${(player.x - player.radius - camera.x) * scale}px`;
                sphere.style.top = `${(player.y - player.radius - camera.y) * scale}px`;
                sphere.style.width = `${playerSize}px`;
                sphere.style.height = `${playerSize}px`;

                // Update UI
                healthBar.style.width = `${(player.health / maxPlayerHealth) * 100}%`;
                const cooldownRatio = playerFireCooldown / playerFireCooldownTime;
                const r = 248 + (250 - 248) * cooldownRatio, g = 250 + (204 - 250) * cooldownRatio, b = 252 + (21 - 252) * cooldownRatio;
                turret.style.backgroundColor = `rgb(${r},${g},${b})`;

                // Render all other game objects
                walls.forEach(w => {
                    w.element.style.left = `${(w.x - camera.x) * scale}px`;
                    w.element.style.top = `${(w.y - camera.y) * scale}px`;
                    w.element.style.width = `${w.width * scale}px`;
                    w.element.style.height = `${w.height * scale}px`;
                });
                fogs.forEach(f => {
                    f.element.style.left = `${(f.x - camera.x) * scale}px`;
                    f.element.style.top = `${(f.y - camera.y) * scale}px`;
                    f.element.style.width = `${f.size * scale}px`;
                    f.element.style.height = `${f.size * scale}px`;
                });
                cobwebs.forEach(c => {
                    c.element.style.left = `${(c.x - camera.x) * scale}px`;
                    c.element.style.top = `${(c.y - camera.y) * scale}px`;
                    c.element.style.width = `${gridSize * scale}px`;
                    c.element.style.height = `${gridSize * scale}px`;
                });
                skeletons.forEach(s => {
                    s.element.style.left = `${(s.x - camera.x) * scale}px`;
                    s.element.style.top = `${(s.y - camera.y) * scale}px`;
                    s.element.style.width = `${gridSize * scale}px`;
                    s.element.style.height = `${gridSize * scale}px`;
                });
                enemies.forEach(e => {
                    const enemySize = e.radius * 2 * scale;
                    e.element.style.left = `${(e.x - e.radius - camera.x) * scale}px`;
                    e.element.style.top = `${(e.y - e.radius - camera.y) * scale}px`;
                    e.element.style.width = `${enemySize}px`;
                    e.element.style.height = `${enemySize}px`;
                });
                bullets.forEach(b => {
                    const bulletSize = b.radius * 2 * scale;
                    b.element.style.left = `${(b.x - b.radius - camera.x) * scale}px`;
                    b.element.style.top = `${(b.y - b.radius - camera.y) * scale}px`;
                    b.element.style.width = `${bulletSize}px`;
                    b.element.style.height = `${bulletSize}px`;
                });
                enemyBullets.forEach(b => {
                    const bulletSize = b.radius * 2 * scale;
                    b.element.style.left = `${(b.x - b.radius - camera.x) * scale}px`;
                    b.element.style.top = `${(b.y - b.radius - camera.y) * scale}px`;
                    b.element.style.width = `${bulletSize}px`;
                    b.element.style.height = `${bulletSize}px`;
                });
                healthPickups.forEach(p => {
                    const pickupSize = p.radius * 2 * scale;
                    p.element.style.left = `${(p.x - p.radius - camera.x) * scale}px`;
                    p.element.style.top = `${(p.y - p.radius - camera.y) * scale}px`;
                    p.element.style.width = `${pickupSize}px`;
                    p.element.style.height = `${pickupSize}px`;
                });
            } else {
                healthBar.style.width = '0%';
            }

            requestAnimationFrame(gameLoop);
        }

        window.onload = () => {
             worldContainer.style.width = `100%`;
             worldContainer.style.height = `100%`;
        }
    </script>
</body>
</html>
